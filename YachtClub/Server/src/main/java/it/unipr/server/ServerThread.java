package it.unipr.server;

import it.unipr.classes.*;
import it.unipr.connection.Response;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

import static it.unipr.constants.Constants.*;

/**
 * The {@code ServerThread} manages a thread
 * generated by the concurrent server {@code Server} to handle an incoming request.
 *
 * @see Server
 *
 * @author Martina Valenti 308044
 * @version 1.0
 * @since 1.0
 */
public class ServerThread implements Runnable {
    private final Socket socket;
    private final Thread thread;

    /**
     * Create new thread.
     *
     * @param socket socket on which the {@code ServerThread}
     * communicates with the {@code Client}
     *
     */
    public ServerThread(Socket socket) {
        this.socket = socket;
        this.thread = new Thread(this, "Thread N." + CURRENT_CONNECTIONS);
        this.thread.start();
        NUM_REQUESTS++;
    }

    /**
     * Methods which sets {@code ObjectInputStream} and {@code ObjectOutputStream}
     * to read {@code Client} request and send it a response.
     */
    public void run() {
        ObjectInputStream is = null;
        ObjectOutputStream os = null;

        try {
            is = new ObjectInputStream(this.socket.getInputStream());
            os = new ObjectOutputStream(this.socket.getOutputStream());
            this.readRequest(is, os);
            this.closeConnection(is, os);
        } catch (Exception e) {
        }
    }

    /**
     * Read {@code Client} request
     */
    private void readRequest(ObjectInputStream input, ObjectOutputStream output) {
        String request = NULL;
        try {
            request = (String) input.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
        handleRequest(request, output);
    }

    /**
     * Executes different queries depending on {@code Client} requests type
     *
     * @param request string that specifies the action to perform
     */
    private void handleRequest(String request, ObjectOutputStream os) {
        String[] message = request.split(REQUEST_SEPARATOR);
        String action = message[0];
        String query;
        List<String> params = Arrays.asList(message[1].split(SEPARATOR));
        Response<?> response = new Response<>();
        Integer result;
        Integer generatedKey;

        switch (action) {
            case MEMBER_LOGIN:
                query = ("SELECT * FROM user WHERE username='%s' and password='%s'").formatted(params.get(0), params.get(1));
                response = this.connectDB(query, MEMBER_PARAMS, "");
                break;
            case STAFF_LOGIN:
                query = ("SELECT * FROM staff WHERE username='%s' and password='%s'").formatted(params.get(0), params.get(1));
                response = this.connectDB(query, STAFF_PARAMS, "");
                break;
            case REGISTRATION:
                query = ("INSERT INTO address VALUES (NULL,'%s', '%s', '%s', '%s')").formatted(params.get(5), params.get(6), params.get(7), params.get(8));
                generatedKey = this.getGeneratedKey(query);
                if (generatedKey!=null) {
                    query = ("INSERT INTO user VALUES ('%s', '%s', '%s','%s', '%s', '%s')").formatted(params.get(0), params.get(1), params.get(2), params.get(3), generatedKey, params.get(4));
                    result = this.updateDatabase(query);
                    response.setMessage((result == 1) ? SUCCESS : FAIL);

                } else {
                    response.setMessage(FAIL);
                }
                break;
            case CHECK_SIGNUP:
                query = ("SELECT COUNT(*) as count FROM user WHERE username='%s'").formatted(params.get(0));
                response = this.connectDB(query, null, "count");
                break;
            case GET_ADDRESS:
                query = ("SELECT * FROM address WHERE id = '%s'").formatted(params.get(0));
                response = this.connectDB(query, ADDRESS_PARAMS, "");
                break;
            case GET_CARDS:
                query = ("SELECT * FROM creditcard WHERE user = '%s'").formatted(params.get(0));
                response = this.connectDB(query, CREDITCARD_PARAMS, "");
                break;
            case GET_BOATS:
                query = ("SELECT * FROM boat WHERE user='%s'").formatted(params.get(0));
                response = this.connectDB(query, BOAT_PARAMS, "");
                break;
            case GET_REG_RACES:
                query = ("SELECT r.id, r.name, r.date, r.entry_fee FROM race r LEFT JOIN race_registration rr ON r.id = rr.race_id GROUP BY r.id, r.name, r.date, r.entry_fee, rr.user_id HAVING rr.user_id = '%s' AND r.date > '%s'").formatted(params.get(0), params.get(1));
                response = this.connectDB(query, RACE_PARAMS, "");
                break;
            case GET_NOT_REG_RACES:
                query = ("SELECT r.id, r.name, r.date, r.entry_fee FROM race r WHERE r.id NOT IN (SELECT r1.id FROM race r1 LEFT JOIN race_registration rr ON r.id = rr.race_id GROUP BY r1.id, rr.user_id HAVING rr.user_id = '%s') AND r.date > '%s'").formatted(params.get(0), params.get(1));
                response = this.connectDB(query, RACE_PARAMS, "");
                break;
            case REGISTER_TO_RACE:
                query = ("INSERT INTO race_registration VALUES ('%s', '%s', '%s')").formatted(params.get(0), params.get(1), params.get(2));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case INSERT_PAYMENT:
                query = ("INSERT INTO payment VALUES (NULL, '%s', '%s', '%s', '%s', '%s')").formatted(params.get(0), params.get(1), params.get(2), params.get(3), params.get(4));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case INSERT_BOAT:
                query = ("INSERT INTO boat VALUES (NULL, '%s', '%s', '%s', '%s')").formatted(params.get(0), params.get(1), params.get(2), params.get(3));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case INSERT_CARD:
                query = ("INSERT INTO creditcard VALUES ('%s', '%s', '%s', '%s', '%s')").formatted(params.get(0), params.get(1), params.get(2), params.get(3), params.get(4));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case DELETE_CARD:
                query = ("DELETE FROM creditcard WHERE number = '%s'").formatted(params.get(0));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case DELETE_NOTIFICATION:
                query = ("DELETE FROM notification WHERE id = '%s'").formatted(params.get(0));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case DELETE_BOAT:
                query = ("DELETE FROM boat WHERE id = '%s'").formatted(params.get(0));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case GET_NOTIFICATIONS:
                query = ("SELECT * FROM notification WHERE user = '%s'").formatted(params.get(0));
                response = this.connectDB(query, NOTIFICATION_PARAMS, "");
                break;
            case UPDATE_MEMBER_FEE:
                query = ("UPDATE user SET annual_fee = '%s' WHERE username = '%s'").formatted(params.get(0), params.get(1));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case GET_PAST_RACES:
                query = ("SELECT * FROM race WHERE date <= '%s'").formatted(params.get(0));
                response = this.connectDB(query, RACE_PARAMS, "");
                break;
            case GET_ALL_RACES:
                query = ("SELECT * FROM race");
                response = this.connectDB(query, RACE_PARAMS, "");
                break;
            case GET_ALL_PAYMENTS:
                query = ("SELECT * FROM payment");
                response = this.connectDB(query, PAYMENT_PARAMS, "");
                break;
            case GET_ALL_BOATS:
                query = ("SELECT * FROM user u JOIN boat b ON u.username=b.user");
                response = this.connectDB(query, BOAT_PARAMS, "");
                break;
            case GET_ALL_MEMBERS:
                query = ("SELECT * FROM user ");
                response = this.connectDB(query, MEMBER_PARAMS, "");
                break;
            case DELETE_RACE:
                query = ("DELETE FROM race WHERE id = '%s'").formatted(params.get(0));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case DELETE_MEMBER:
                query = ("DELETE FROM user WHERE username = '%s'").formatted(params.get(0));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case ADD_NOTIFICATION:
                query = ("INSERT INTO notification VALUES (NULL, '%s', '%s')").formatted(params.get(0), params.get(1));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case ADD_RACE:
                query = ("INSERT INTO race VALUES (NULL, '%s', '%s', '%s')").formatted(params.get(0), params.get(1), params.get(2));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case UPDATE_BOAT:
                query = ("UPDATE boat SET annual_fee_expiry = '%s' WHERE id = '%s'").formatted(params.get(0), params.get(1));
                result = this.updateDatabase(query);
                response.setMessage((result == 1) ? SUCCESS : FAIL);
                break;
            case NULL:
                break;
            default:
                response(os, new Response<>(DEFAULT));
                return;
        }
        if (response.isEmpty()) {
            response(os, new Response<>(FAIL));
        }
        else{
            response(os, response);
        }
    }

    /**
     * This method write the response to the output stream
     *
     * @param os  ObjectOutputStream to write to
     * @param response response send back to the client
     * @param <T> type of the message
     */
    public static <T> void response(ObjectOutputStream os, T response) {
        try {
            os.writeObject(response);  // Request executed correctly
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void closeConnection(ObjectInputStream is, ObjectOutputStream os) {
        CURRENT_CONNECTIONS--;
        try {
            is.close();
            socket.close();
        } catch (IOException e) {
            return;
        }

        try {
            os.close();
        } catch (IOException e) {
            return;
        }
        this.thread.interrupt();
    }


    private Response<?> createResponse(ResultSet rs, String[] params) {
        System.out.println(params);
        HashMap<String, String> values = new HashMap<>();
        try {
            switch (params[0]) {
                case "Member" -> {
                    List<Member> list = new ArrayList<>();
                    if (rs.isBeforeFirst()) {
                        while (rs.next()) {
                            for (int i = 1; i < params.length; i++) {
                                values.put(params[i], rs.getString(params[i]));
                            }
                            Member member = new Member(values);
                            list.add(member);
                        }
                    }
                    Response<Member> response = new Response<>(list);
                    response.setEmpty(false);
                    return response;
                }
                case "Staff" -> {
                    List<Staff> list = new ArrayList<>();
                    if (rs.isBeforeFirst()) {
                        while (rs.next()) {
                            for (int i = 1; i < params.length; i++)
                                values.put(params[i], rs.getString(params[i]));
                            Staff staff = new Staff(values);
                            list.add(staff);
                        }
                    }
                    Response<Staff> response = new Response<>(list);
                    response.setEmpty(false);
                    return response;
                }
                case "Address" -> {
                    List<Address> list = new ArrayList<>();
                    if (rs.isBeforeFirst()) {
                        while (rs.next()) {
                            for (int i = 1; i < params.length; i++) {
                                values.put(params[i], rs.getString(params[i]));
                            }
                            Address address = new Address(values);
                            list.add(address);
                        }
                    }
                    Response<Address> response = new Response<>(list);
                    response.setEmpty(false);
                    return response;
                }
                case "Boat" -> {
                    List<Boat> list = new ArrayList<>();
                    if (rs.isBeforeFirst()) {
                        while (rs.next()) {
                            for (int i = 1; i < params.length; i++)
                                values.put(params[i], rs.getString(params[i]));
                            Boat boat = new Boat(values);
                            list.add(boat);
                        }
                    }
                    Response<Boat> response = new Response<>(list);
                    response.setEmpty(false);
                    return response;
                }
                case "Race" -> {
                    List<Race> list = new ArrayList<>();
                    if (rs.isBeforeFirst()) {
                        while (rs.next()) {
                            for (int i = 1; i < params.length; i++)
                                values.put(params[i], rs.getString(params[i]));
                            Race race = new Race(values);
                            list.add(race);
                        }
                    }
                    Response<Race> response = new Response<>(list);
                    response.setEmpty(false);
                    return response;
                }
                case "CreditCard" -> {
                    List<CreditCard> list = new ArrayList<>();
                    if (rs.isBeforeFirst()) {
                        while (rs.next()) {
                            for (int i = 1; i < params.length; i++)
                                values.put(params[i], rs.getString(params[i]));
                            CreditCard card = new CreditCard(values);
                            list.add(card);
                        }
                    }
                    Response<CreditCard> response = new Response<>(list);
                    response.setEmpty(false);
                    return response;
                }
                case "Payment" -> {
                    List<Payment> list = new ArrayList<>();
                    if (rs.isBeforeFirst()) {
                        while (rs.next()) {
                            for (int i = 1; i < params.length; i++)
                                values.put(params[i], rs.getString(params[i]));

                            Payment pay = new Payment(values);
                            list.add(pay);
                        }
                    }
                    Response<Payment> response = new Response<>(list);
                    response.setEmpty(false);
                    return response;
                }
                case "Notification" -> {
                    List<Notification> list = new ArrayList<>();
                    if (rs.isBeforeFirst()) {
                        while (rs.next()) {
                            for (int i = 1; i < params.length; i++)
                                values.put(params[i], rs.getString(params[i]));
                            Notification not = new Notification(values);
                            list.add(not);
                        }
                    }
                    Response<Notification> response = new Response<>(list);
                    response.setEmpty(false);
                    return response;
                }
            }
        }catch (Exception e) {
        }
        return null;
    }

    private Response<String> noParamResponse(ResultSet rs, String column) {
        Response<String> response = new Response<>();
        try {
            if (rs.isBeforeFirst()) {
                while (rs.next()) {
                    response = new Response<>();
                    response.setMessage(rs.getString(column));
                }
            }
            return response;
        } catch (Exception e) {
        }
        return null;
    }
    private Response<?> connectDB(String query, String[] params, String column) {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection connection = DriverManager.getConnection(DB_URL, DB_USERNAME, DB_PASSWORD);
            Statement stm = connection.createStatement();
            ResultSet resultSet = stm.executeQuery(query);
            Response<?> response;
            if (params != null) {
                response = createResponse(resultSet, params);
            }
            else {
                response = noParamResponse(resultSet, column);
            }
            connection.close();
            return response;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private Integer updateDatabase(String query) {

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection conn = DriverManager.getConnection(DB_URL, DB_USERNAME, DB_PASSWORD);
            Statement stm = conn.createStatement();
            Integer result = stm.executeUpdate(query);
            conn.close();
            return result;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private Integer getGeneratedKey(String query) {
        ResultSet rs = null;
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection conn = DriverManager.getConnection(DB_URL, DB_USERNAME, DB_PASSWORD);
            Statement stm = conn.createStatement();
            stm.executeUpdate(query,Statement.RETURN_GENERATED_KEYS);
            rs = stm.getGeneratedKeys();
            if (rs.next()) {
                int generatedKey = rs.getInt(1);
                conn.close();
                return generatedKey;
            } else{
                throw new Exception("Something went wrong while getting AUTO_INCREMENT column value");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

}
